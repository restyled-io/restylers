#!/usr/bin/env bash
# shellcheck disable=SC2001
set -euo pipefail

tmp=$(mktemp)
trap 'rm -rf "$tmp"' EXIT

gh pr list \
  --author 'renovate[bot]' \
  --base main \
  --state all \
  --limit 100 \
  --json title \
  --jq '.[] | .title' | while read -r title; do
    read -r dep < <(sed 's/^feat(\(.*\)): .*$/\1/' <<<"$title")
    read -r msg < <(sed 's/^feat(.*): \(.*\)$/\1/' <<<"$title")
    grep -Fwo "$dep" <<<"$msg" || true
  done |
  sort -u >"$tmp"

manifests=(
  Gemfile
  package.json
  requirements.txt
  stack.yaml
)

ret=0
updated=()
waiting=()
missing=()
skipped=()

swaps='
cmake-format: cmakelang
prettier-ruby: prettier
sqlformat: sqlparse
standardrb: standard
'

check_info() {
  local info=$1

  dep=$(dirname "$info")

  read -r override < <(yq '.overrides' "$dep"/info.yaml)

  # If it's an override, skip it
  if [[ "$override" != null ]]; then
    skipped+=("$dep is an override of $override")
    return 0
  fi

  # If we have a PR we're good
  if grep -Fxq "$dep" "$tmp"; then
    updated+=("$dep is updated by renovate")
    return 0
  fi

  # If we have regex comments, it's maintained
  if grep -q "^# renovate: .* depName=$dep\( \|$\)" ./*/Dockerfile; then
    waiting+=("$dep is configured, but not yet updated by renovate (Dockerfile)")
    return 0
  fi

  # If we're using a manifest that mentions it, it's maintained
  for m in "${manifests[@]}"; do
    if [[ -f "$dep/$m" ]]; then
      read -r n < <(awk "/^$dep: /"' {print $2}' <<< "$swaps") || n=$dep

      if grep -Fqw "$n" "$dep/$m"; then
        waiting+=("$dep is configured, but not yet updated by renovate ($m -> $n)")
        return 0
      else
        printf 'Warning: %s/%s exists, but does not reference %s\n' "$dep" "$m" "$n" >&2
      fi
    fi
  done

  missing+=("$dep is not renovate-maintained")
  return 1
}

for info in */info.yaml; do
  if ! check_info "$info"; then
    ret=1
  fi
done

printf '\e[1m%s\e[0m: %d\n' "Skipped" "${#skipped[@]}"
for x in "${skipped[@]}"; do
  read -r dep msg <<<"$x"
  printf '  \e[1;36m·\e[0m \e[35m%s\e[0m %s\n' "$dep" "$msg"
done
echo

printf '\e[1m%s\e[0m: %d\n' "Updated" "${#updated[@]}"
for x in "${updated[@]}"; do
  read -r dep msg <<<"$x"
  printf '  \e[32m✓\e[0m \e[35m%s\e[0m %s\n' "$dep" "$msg"
done
echo

printf '\e[1m%s\e[0m: %d\n' "Waiting" "${#waiting[@]}"
for x in "${waiting[@]}"; do
  read -r dep msg <<<"$x"
  printf '  \e[1;33m⏲\e[0m \e[35m%s\e[0m %s\n' "$dep" "$msg"
done
echo

printf '\e[1m%s\e[0m: %d\n' "Missing" "${#missing[@]}"
for x in "${missing[@]}"; do
  read -r dep msg <<<"$x"
  printf '  \e[31m✗\e[0m \e[35m%s\e[0m %s\n' "$dep" "$msg"
done
echo

exit "$ret"
